#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/setup"
require "gli"
require_relative "../lib/soba"

include GLI::App

program_desc "GitHub to Claude Code workflow automation"
version Soba::VERSION

desc "Configuration file path"
flag [:c, :config]

desc "Verbose output"
switch [:v, :verbose]

desc "Initialize soba configuration"
command :init do |c|
  c.desc "Interactive mode for configuration"
  c.switch [:i, :interactive]

  c.action do |global_options, options, _args|
    require_relative "../lib/soba/commands/init"
    Soba::Commands::Init.new(interactive: options[:interactive]).execute
  end
end

desc "Show configuration"
command :config do |c|
  c.action do |global_options, _options, _args|
    require_relative "../lib/soba/commands/config/show"
    Soba::Commands::Config::Show.new.execute(
      config_path: global_options[:config],
    )
  end
end

desc "Start workflow automation"
command :start do |c|
  c.desc "Issue number to process (optional)"
  c.arg_name "[issue_number]"

  c.desc "Disable tmux execution"
  c.switch ["no-tmux"]

  c.desc "Run in foreground mode (default is daemon mode)"
  c.switch [:f, :foreground]

  c.action do |global_options, options, args|
    require_relative "../lib/soba/commands/start"
    result = Soba::Commands::Start.new.execute(global_options, options, args)
    if result.is_a?(Integer) && result != 0
      exit(result)
    end
  end
end

desc "Show daemon status"
command :status do |c|
  c.flag [:l, :log], desc: "Number of log lines to display", type: Integer, default_value: 10
  c.switch [:j, :json], desc: "Output in JSON format", negatable: false

  c.action do |global_options, options, args|
    require_relative "../lib/soba/commands/status"
    result = Soba::Commands::Status.new.execute(global_options, options, args)
    if result.is_a?(Integer) && result != 0
      exit(result)
    end
  end
end

desc "Stop daemon"
command :stop do |c|
  c.switch [:f, :force], desc: "Force kill immediately without waiting", negatable: false
  c.flag [:t, :timeout], desc: "Timeout in seconds", type: Integer, default_value: 30

  c.action do |global_options, options, args|
    require_relative "../lib/soba/commands/stop"
    result = Soba::Commands::Stop.new.execute(global_options, options, args)
    if result.is_a?(Integer) && result != 0
      exit(result)
    end
  end
end

desc "Open tmux session for a task"
command :open do |c|
  c.desc "Task number to open"
  c.arg_name "[task_number]"

  c.desc "List active task sessions"
  c.switch [:l, :list]

  c.action do |global_options, options, args|
    require_relative "../lib/soba/commands/open"
    command = Soba::Commands::Open.new
    issue_number = args[0] unless args.empty?
    command.execute(issue_number, list: options[:list])
  end
end

pre do |global, _command, _options, _args|
  if global[:verbose]
    Soba.logger.level = :debug
  end
  true
end

on_error do |exception|
  Soba.logger.error(exception.message)
  Soba.logger.debug(exception.backtrace.join("\n")) if Soba.logger.debug?
  false
end

exit run(ARGV)